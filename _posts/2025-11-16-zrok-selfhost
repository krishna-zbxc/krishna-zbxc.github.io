

---
layout: post
title: "How to Self-Host zrok on Your Domain"
date: 2025-11-16
categories: self-hosting tutorial
---

## Introduction  
zrok (pronounced *“zee-rock”*) is an open-source sharing platform built to make exposing, sharing and securely accessing your services, files or applications **easy** and **safe**. It’s powered by the OpenZiti zero-trust overlay network which means you don’t have to open inbound ports, wrestle with NAT or rely purely on third-party tunnels.

With zrok you can either use a public service instance or self-host your own environment. Whether you’re wanting a quick public web share (for demos) or a robust self-hosted zero-trust tunnel for production, zrok supports both with commands like `zrok enable`, `zrok share`, and more.

In this tutorial we’ll walk through how to self-host zrok on your own domain, configure Nginx and TLS, issue wildcard certificates, and get your first share up and running — so you’re fully in control of your sharing stack.

---

## 1. Set Up Environment Variables  
On your server (e.g., `example.com`), define the necessary variables:  
```bash
export ZROK_DNS_ZONE=zrok.example.com  
export ZROK_USER_EMAIL=you@example.com  
export ZROK_USER_PWD=YourPassword123  
export ZITI_PWD=YourPassword123  
export ZROK_ADMIN_TOKEN=YourAdminToken  
export ZROK_INSECURE_INTERFACE=0.0.0.0  
export ZROK_CTRL_PORT=18080  
export ZROK_FRONTEND_PORT=8080  
export ZITI_CTRL_ADVERTISED_PORT=80  
export ZITI_ROUTER_PORT=3022  
````

## 2. Deploy with Docker Compose

Run:

```bash
docker compose up --build --detach
```

Ensure services start without port-binding errors (e.g., port 80 already in use).

## 3. Configure Nginx Reverse Proxy & TLS

Here’s a sample `nginx` configuration supporting your main domain, API endpoint and wildcard sub-domains:

```nginx
server {
    listen       80;
    listen       [::]:80;
    server_name  example.com www.example.com api.zrok.example.com *.zrok.example.com;
    return       301 https://$host$request_uri;
}

server {
    listen       443 ssl http2;
    listen       [::]:443 ssl http2;
    server_name  example.com www.example.com;

    ssl_certificate     /etc/letsencrypt/live/example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;
    include             /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam         /etc/letsencrypt/ssl-dhparams.pem;

    location / {
        proxy_pass         http://localhost:5678;
        proxy_http_version 1.1;

        # WebSocket support
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";

        # Forward headers
        proxy_set_header Host             $host;
        proxy_set_header X-Real-IP        $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Timeouts
        proxy_read_timeout    600s;
        proxy_send_timeout    600s;
        proxy_connect_timeout 600s;

        proxy_buffering off;
    }
}

server {
    listen       443 ssl http2;
    listen       [::]:443 ssl http2;
    server_name  api.zrok.example.com;

    ssl_certificate     /etc/letsencrypt/live/example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;
    include             /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam         /etc/letsencrypt/ssl-dhparams.pem;

    location / {
        proxy_pass         http://127.0.0.1:18080;
        proxy_set_header   Host             $host;
        proxy_set_header   X-Real-IP        $remote_addr;
        proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header   X-Forwarded-Proto $scheme;
    }
}

server {
    listen       443 ssl http2;
    listen       [::]:443 ssl http2;
    server_name  *.zrok.example.com;

    ssl_certificate     /etc/letsencrypt/live/example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;
    include             /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam         /etc/letsencrypt/ssl-dhparams.pem;

    location / {
        proxy_pass             http://127.0.0.1:8080;
        proxy_set_header       Host             $host;
        proxy_http_version     1.1;
        proxy_set_header       Upgrade          $http_upgrade;
        proxy_set_header       Connection       "upgrade";
        proxy_set_header       X-Real-IP        $remote_addr;
        proxy_set_header       X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header       X-Forwarded-Proto $scheme;

        proxy_busy_buffers_size 512k;
        proxy_buffers           4 512k;
        proxy_buffer_size       256k;
    }
}
```

## 4. Issue Wildcard TLS Certificate

Use Certbot to generate a certificate covering your main domain and wildcard zone:

```bash
sudo certbot certonly \
  --manual \
  --preferred-challenges=dns \
  --email you@example.com \
  --agree-tos \
  -d example.com \
  -d www.example.com \
  -d *.zrok.example.com
```

When prompted, create the `_acme-challenge.zrok.example.com` TXT record with the given value.
Verify via:

```bash
echo | openssl s_client -connect api.zrok.example.com:443 -servername api.zrok.example.com \
  | openssl x509 -noout -text | grep -A1 "Subject Alternative Name"
```

It should list: `DNS: *.zrok.example.com`, `DNS: example.com`, `DNS: www.example.com`.

## 5. Configure the zrok CLI & Enable Environment

On your client machine install the `zrok` CLI and then set the API endpoint:

```bash
zrok config set apiEndpoint https://api.zrok.example.com
```

Create an account on the server:

```bash
docker compose exec zrok-controller zrok admin create account your-email@example.com YourPassword
```

Note the token returned. On your client run:

```bash
zrok enable <your-token>
```

Once succeeded, you can create a share:

```bash
zrok share public http://localhost:8000
```

## 6. Common Problems & Solutions

* **“HTTP response to HTTPS client”**: This means you set `apiEndpoint` to an HTTPS URL but the server listens on HTTP (or different port). Fix it by ensuring the URL/protocol/port match your Nginx & Docker setup.
* **“FOREIGN KEY constraint failed” in logs**: The server attempted to insert an environment linked to a missing account. Make sure you created the account first via `zrok admin create account`, then used the returned token to `zrok enable`.
* **Wildcard certificate doesn’t cover sub-domain**: Ensure the `Subject Alternative Name` contains `*.zrok.example.com`. If missing, re-issue certificate with `-d *.zrok.example.com`.
* **Port binding failed on deploy**: If Docker reports “address already in use” for port 80 or 443, change your `ZITI_CTRL_ADVERTISED_PORT` or host binding to a free port, or stop the conflicting service.
* **DNS for wildcard not resolving**: Make sure you added both `api.zrok.example.com` A/AAAA record and a wildcard `*.zrok.example.com` record pointing to your server’s IP.

---

## Conclusion

By completing this setup you’ll now have a self-hosted zrok environment on your domain, with:

* A wildcard certificate covering `*.zrok.example.com`, `example.com`, `www.example.com`
* Nginx reverse-proxy forwarding the main domain, the API endpoint and wildcard shares
* zrok CLI configured and enabled, ready for public or private sharing
* Understanding of common pitfalls (certificate mismatches, port conflicts, account setup)

With this foundation, you can rapidly share web apps, files, or even private services (behind the scenes) securely and privately. If you ever need to scale up, set up **automatic renewal** of your certificates or automate DNS challenges — you’ll already have the key architecture in place.

Happy hosting, and welcome to the world of self-hosted, zero-trust resource access!



